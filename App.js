// @flow

import React, { Component } from 'react'
import {
  StyleSheet,
  Text,
  ScrollView,View,TouchableHighlight,NativeModules
} from 'react-native'

import Base64 from 'base64-js'
import Sodium from 'react-native-sodium'

class TestResult extends Component {
    render() {
      const text = (this.props.value == null) ? "?" :(this.props.value ? "Pass":"Fail")
      const style = {color:(this.props.value == null ? "black" : (this.props.value ? "green":"red"))}
      return (
        <View style={styles.testContainer}>
          <Text style={styles.testLabel}>{this.props.name}:</Text>
          <Text style={[styles.testResult,style]}>{this.props.value}</Text>
        </View>
      );
    }

  }

class TestValue extends Component {
    render() {
      return (
        <View style={styles.testContainer}>
          <Text style={styles.testLabel}>{this.props.name}:</Text>
          <Text style={[styles.testResult]}>{this.props.value}</Text>
        </View>
      );
    }

  }

export default class Example extends Component {

  state: {
    sodium_version_string: string,
    input_string: string,
    public_key: string,
    secret_key: string,
    nonce: string,
    chiper: string
   }

  constructor(props) {
    super(props)
    this.state = {}
  }


  _handleError(error) {
    console.log(error)
    this.setState({sodiumError: error})
  }

  _testRandom1() {
    this.setState({randombytes_uniform:null})
    let freq = [];
    let p = []
    for (i = 0; i < 256; ++i) freq[i] = 0;
    for (i = 0; i < 20*256; ++i) p.push(Sodium.randombytes_uniform(256).then((v) => ++freq[v]))
    Promise.all(p).then(() => {
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_uniform:!fail})
    })
  }

  _testRandom2() {
    this.setState({randombytes_buf:null})
    let freq = [];
    for (i = 0; i < 256; ++i) freq[i] = 0;
    Sodium.randombytes_buf(20*256).then((value) => {
      let a = Base64.toByteArray(value)
      for (i = 0; i < a.length; ++i) ++freq[a[i]]
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_buf:!fail})
    })
  }

  _testRandom3() {
    this.setState({randombytes_random:null})
    let freq = [];
    let p = []
    for (i = 0; i < 256; ++i) freq[i] = 0;
    for (i = 0; i < 5*256; ++i) p.push(Sodium.randombytes_random().then((v) => {
      ++freq[v & 0xff]
      ++freq[(v >>> 8) & 0xff]
      ++freq[(v >>> 16) & 0xff]
      ++freq[(v >>> 24) & 0xff]
    }))
    Promise.all(p).then(() => {
      var fail = false
      for (i = 0; i < 256 && !fail; ++i) if (!freq[i]) fail = true
      this.setState({randombytes_random:!fail})
    })
  }

  _testSecretBox1() {

    const k = Base64.fromByteArray(new Uint8Array([
      0x1b, 0x27, 0x55, 0x64, 0x73, 0xe9, 0x85, 0xd4, 0x62, 0xcd, 0x51, 0x19, 0x7a, 0x9a, 0x46, 0xc7,
      0x60, 0x09, 0x54, 0x9e, 0xac, 0x64, 0x74, 0xf2, 0x06, 0xc4, 0xee, 0x08, 0x44, 0xf6, 0x83, 0x89]))

    const n = Base64.fromByteArray(new Uint8Array([
      0x69, 0x69, 0x6e, 0xe9, 0x55, 0xb6, 0x2b, 0x73, 0xcd, 0x62, 0xbd, 0xa8,
      0x75, 0xfc, 0x73, 0xd6, 0x82, 0x19, 0xe0, 0x03, 0x6b, 0x7a, 0x0b, 0x37]))

    const m = Base64.fromByteArray(new Uint8Array([
      0xbe, 0x07, 0x5f, 0xc5, 0x3c, 0x81, 0xf2, 0xd5, 0xcf, 0x14, 0x13, 0x16,
      0xeb, 0xeb, 0x0c, 0x7b, 0x52, 0x28, 0xc5, 0x2a, 0x4c, 0x62, 0xcb, 0xd4,
      0x4b, 0x66, 0x84, 0x9b, 0x64, 0x24, 0x4f, 0xfc, 0xe5, 0xec, 0xba, 0xaf,
      0x33, 0xbd, 0x75, 0x1a, 0x1a, 0xc7, 0x28, 0xd4, 0x5e, 0x6c, 0x61, 0x29,
      0x6c, 0xdc, 0x3c, 0x01, 0x23, 0x35, 0x61, 0xf4, 0x1d, 0xb6, 0x6c, 0xce,
      0x31, 0x4a, 0xdb, 0x31, 0x0e, 0x3b, 0xe8, 0x25, 0x0c, 0x46, 0xf0, 0x6d,
      0xce, 0xea, 0x3a, 0x7f, 0xa1, 0x34, 0x80, 0x57, 0xe2, 0xf6, 0x55, 0x6a,
      0xd6, 0xb1, 0x31, 0x8a, 0x02, 0x4a, 0x83, 0x8f, 0x21, 0xaf, 0x1f, 0xde,
      0x04, 0x89, 0x77, 0xeb, 0x48, 0xf5, 0x9f, 0xfd, 0x49, 0x24, 0xca, 0x1c,
      0x60, 0x90, 0x2e, 0x52, 0xf0, 0xa0, 0x89, 0xbc, 0x76, 0x89, 0x70, 0x40,
      0xe0, 0x82, 0xf9, 0x37, 0x76, 0x38, 0x48, 0x64, 0x5e, 0x07, 0x05]))

    const handleError = (e) => {this.setState({crypto_secretbox1:false});console.log(e)}
    this.setState({crypto_secretbox1:null})

    Sodium.crypto_secretbox_easy(m, n, k)
     .then((c) => Sodium.crypto_secretbox_open_easy(c,n,k),handleError)
     .then((mm) => this.setState({crypto_secretbox1:(m === mm)}),handleError)
  }

  _testAuth1() {
    const k = Base64.fromByteArray(new Uint8Array([
      // Jefe
      0x4a,0x65,0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00]))

    const c = Base64.fromByteArray(new Uint8Array([
      // what do ya want for nothing?
      0x77,0x68,0x61,0x74,0x20,0x64,0x6f,0x20,0x79,0x61,0x20,0x77,0x61,0x6e,
      0x74,0x20,0x66,0x6f,0x72,0x20,0x6e,0x6f,0x74,0x68,0x69,0x6e,0x67,0x3f]))

    const a = Base64.fromByteArray(new Uint8Array([
      0x16,0x4b,0x7a,0x7b,0xfc,0xf8,0x19,0xe2,0xe3,0x95,0xfb,0xe7,0x3b,0x56,0xe0,0xa3,
      0x87,0xbd,0x64,0x22,0x2e,0x83,0x1f,0xd6,0x10,0x27,0x0c,0xd7,0xea,0x25,0x05,0x54]))

    this.setState({crypto_auth:null,crypto_auth_verify:null})

    Sodium.crypto_auth(c,k).then((aa) => {
      this.setState({crypto_auth:(a === aa)})
      Sodium.crypto_auth_verify(a,c,k)
        .then((r) => this.setState({crypto_auth_verify:(r == 0)}))
        .catch((error) => {
          this.setState({crypto_auth_verify:false})
          this._handleError(error)
        })
    }).catch((error) => {
      this.setState({crypto_auth_verify:false})
      this._handleError(error)
    })
  }

  _testBox1() {
    this.setState({crypto_box1:null})
    const mlen_max = 1000

    Promise.all([Sodium.crypto_box_keypair(),Sodium.crypto_box_keypair()]).then(([alice,bob]) => {
      let p = []
      for (mlen = 0; mlen <= mlen_max; mlen++) {
        p.push(
          Promise.all([
            Sodium.randombytes_buf(Sodium.crypto_box_NONCEBYTES),
            Sodium.randombytes_buf(mlen)
          ]).then(([n,m]) =>
             Sodium.crypto_box_easy(m,n,bob.pk,alice.sk)
              .then((c) => Sodium.crypto_box_open_easy(c,n,alice.pk,bob.sk))
              .then((mm) => mm === m))
        )
      }
      Promise.all(p).then((pr) => {
        let fail = false
        for (i = 0; i < pr.length && !fail; ++i) if (!pr[i]) fail = true
        this.setState({crypto_box1:!fail})
      })
    })
  }

  _testBox2() {
    this.setState({crypto_box2:null})
    const alicepk = Base64.fromByteArray(new Uint8Array([
      0x85,0x20,0xf0,0x09,0x89,0x30,0xa7,0x54,0x74,0x8b,0x7d,0xdc,0xb4,0x3e,0xf7,0x5a,
      0x0d,0xbf,0x3a,0x0d,0x26,0x38,0x1a,0xf4,0xeb,0xa4,0xa9,0x8e,0xaa,0x9b,0x4e,0x6a]))

    const alicesk = Base64.fromByteArray(new Uint8Array([
      0x77,0x07,0x6d,0x0a,0x73,0x18,0xa5,0x7d,0x3c,0x16,0xc1,0x72,0x51,0xb2,0x66,0x45,
      0xdf,0x4c,0x2f,0x87,0xeb,0xc0,0x99,0x2a ,0xb1,0x77,0xfb,0xa5,0x1d,0xb9,0x2c,0x2a]))

    const bobpk = Base64.fromByteArray(new Uint8Array([
      0xde,0x9e,0xdb,0x7d,0x7b,0x7d,0xc1,0xb4,0xd3,0x5b,0x61,0xc2,0xec,0xe4,0x35,0x37,
      0x3f,0x83,0x43,0xc8,0x5b,0x78,0x67,0x4d ,0xad,0xfc,0x7e,0x14,0x6f,0x88,0x2b,0x4f]))

    const bobsk = Base64.fromByteArray(new Uint8Array([
      0x5d,0xab,0x08,0x7e,0x62,0x4a,0x8a,0x4b,0x79,0xe1,0x7f,0x8b,0x83,0x80,0x0e,0xe6,
      0x6f,0x3b,0xb1,0x29,0x26,0x18,0xb6,0xfd,0x1c,0x2f,0x8b,0x27,0xff,0x88,0xe0,0xeb]))

    const nonce = Base64.fromByteArray(new Uint8Array([
      0x69,0x69,0x6e,0xe9,0x55,0xb6,0x2b,0x73,0xcd,0x62,0xbd,0xa8,
      0x75,0xfc,0x73,0xd6 ,0x82,0x19,0xe0,0x03,0x6b,0x7a,0x0b,0x37]))

    const m = Base64.fromByteArray(new Uint8Array([
      0xbe,0x07,0x5f,0xc5,0x3c,0x81,0xf2,0xd5,0xcf,0x14,0x13,0x16,0xeb,0xeb,0x0c,0x7b,
      0x52,0x28,0xc5,0x2a,0x4c,0x62,0xcb,0xd4,0x4b,0x66,0x84,0x9b,0x64,0x24,0x4f,0xfc,
      0xe5,0xec,0xba,0xaf,0x33,0xbd,0x75,0x1a,0x1a,0xc7,0x28,0xd4,0x5e,0x6c,0x61,0x29,
      0x6c,0xdc,0x3c,0x01,0x23,0x35,0x61,0xf4,0x1d,0xb6,0x6c,0xce,0x31,0x4a,0xdb,0x31,
      0x0e,0x3b,0xe8,0x25,0x0c,0x46,0xf0,0x6d,0xce,0xea,0x3a,0x7f,0xa1,0x34,0x80,0x57,
      0xe2,0xf6,0x55,0x6a,0xd6,0xb1,0x31,0x8a,0x02,0x4a,0x83,0x8f,0x21,0xaf,0x1f,0xde,
      0x04,0x89,0x77,0xeb,0x48,0xf5,0x9f,0xfd,0x49,0x24,0xca,0x1c,0x60,0x90,0x2e,0x52,
      0xf0,0xa0,0x89,0xbc,0x76,0x89,0x70,0x40,0xe0,0x82,0xf9,0x37,0x76,0x38,0x48,0x64,
      0x5e,0x07,0x05]))

    const c =  Base64.fromByteArray(new Uint8Array([
      0xf3,0xff,0xc7,0x70,0x3f,0x94,0x00,0xe5,0x2a,0x7d,0xfb,0x4b,0x3d,0x33,0x05,0xd9,
      0x8e,0x99,0x3b,0x9f,0x48,0x68,0x12,0x73,0xc2,0x96,0x50,0xba,0x32,0xfc,0x76,0xce,
      0x48,0x33,0x2e,0xa7,0x16,0x4d,0x96,0xa4,0x47,0x6f,0xb8,0xc5,0x31,0xa1,0x18,0x6a,
      0xc0,0xdf,0xc1,0x7c,0x98,0xdc,0xe8,0x7b,0x4d,0xa7,0xf0,0x11,0xec,0x48,0xc9,0x72,
      0x71,0xd2,0xc2,0x0f,0x9b,0x92,0x8f,0xe2,0x27,0x0d,0x6f,0xb8,0x63,0xd5,0x17,0x38,
      0xb4,0x8e,0xee,0xe3,0x14,0xa7,0xcc,0x8a,0xb9,0x32,0x16,0x45,0x48,0xe5,0x26,0xae,
      0x90,0x22,0x43,0x68,0x51,0x7a,0xcf,0xea,0xbd,0x6b,0xb3,0x73,0x2b,0xc0,0xe9,0xda,
      0x99,0x83,0x2b,0x61,0xca,0x01,0xb6,0xde,0x56,0x24,0x4a,0x9e,0x88,0xd5,0xf9,0xb3,
      0x79,0x73,0xf6,0x22,0xa4,0x3d,0x14,0xa6,0x59,0x9b,0x1f,0x65,0x4c,0xb4,0x5a,0x74,
      0xe3,0x55,0xa5]))

      Sodium.crypto_box_easy(m,nonce,bobpk,alicesk).then((cc) => {
        Sodium.crypto_box_open_easy(cc,nonce,alicepk,bobsk).then((mm) => {
          this.setState({crypto_box2:(c === cc && m === mm)})
        })
      })
  };

  _mytest() {

    Sodium.crypto_box_keypair().then(alice => {
      console.log('my public key is', alice.pk);
      console.log('my secret key is', alice.sk);
      this.setState({ public_key: alice.pk, secret_key: alice.sk, input_string: 'Hello World' });
      Sodium.randombytes_buf(Sodium.crypto_box_NONCEBYTES).then(
        nonce => {
        console.log('nonce is', nonce);
        this.setState({ nonce: nonce });
        Sodium.crypto_box_easy(
        'Hello World',
        nonce,
        '/AllqhynaA/pvvdMhoILo2YNxQ1MnxtQlOKTR1jZV0I=',
        alice.sk,
        ).then(c => { console.log('cipher is', c); this.setState({ chiper: c })});
        },
      );
      });
    }


  _testSodium() {
    Sodium.sodium_version_string()
      .then((version) => this.setState({sodium_version_string: version}))
      .catch((error) => this._handleError(error))

    // Random data generation
    // this._testRandom1()
    // this._testRandom2()
    // this._testRandom3()

    // Secret key cryptography - authenticated encryption
    // this._testSecretBox1()

    // Secret key cryptography - authentication
    // this._testAuth1()

    // Public-key cryptography - authenticated encryption
    // this._testBox1()
    // this._testBox2()
    this._mytest();
  }

  componentDidMount() {
     this._testSodium()
  }

  render() {
    return (
      <ScrollView style={{flex:1}}>
        <TouchableHighlight onPress={() => this._testSodium()}>
          <Text style={styles.welcome}>
            Salted React Native!
          </Text>
        </TouchableHighlight>
        <TestValue name="Input String" value={this.state.input_string}/>
        <TestResult name="Public Key" value={this.state.public_key}/>
        <TestResult name="Secret Key" value={this.state.secret_key}/>
        <TestResult name="nonce" value={this.state.nonce}/>
        <TestResult name = "cipher" value={this.state.chiper}/>
      </ScrollView>
    )
  }

}

const styles = StyleSheet.create({
  container: {
    flex: 1,
   //justifyContent: 'center',
    //alignItems: 'center',
    backgroundColor: '#F5FCFF',
    padding:5
  },

  testContainer: {
    flex: 1,
    flexDirection:'row',
    padding:5
  },

  testLabel: {
    flex:4,
    textAlign: 'left',
    color: '#333333',
  },

  testResult: {
    flex:7,
    textAlign: 'center',
  },

  welcome: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
  },
  instructions: {
    textAlign: 'left',
    color: '#333333',
    marginBottom: 5,
  },
})
